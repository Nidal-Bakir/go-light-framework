// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: otp_challenge.sql

package database_queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const otpChallengeDelete = `-- name: OtpChallengeDelete :exec
DELETE
FROM otp_challenge
WHERE id = $1
`

// OtpChallengeDelete
//
//	DELETE
//	FROM otp_challenge
//	WHERE id = $1
func (q *Queries) OtpChallengeDelete(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, otpChallengeDelete, id)
	return err
}

const otpChallengeGet = `-- name: OtpChallengeGet :one
SELECT id, otp_hash, channel, attempts, purpose, created_at, updated_at, expires_at
FROM otp_challenge
WHERE id = $1 
    AND expires_at < NOW()
LIMIT 1
`

// OtpChallengeGet
//
//	SELECT id, otp_hash, channel, attempts, purpose, created_at, updated_at, expires_at
//	FROM otp_challenge
//	WHERE id = $1
//	    AND expires_at < NOW()
//	LIMIT 1
func (q *Queries) OtpChallengeGet(ctx context.Context, id uuid.UUID) (OtpChallenge, error) {
	row := q.db.QueryRow(ctx, otpChallengeGet, id)
	var i OtpChallenge
	err := row.Scan(
		&i.ID,
		&i.OtpHash,
		&i.Channel,
		&i.Attempts,
		&i.Purpose,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const otpChallengeIncAttempt = `-- name: OtpChallengeIncAttempt :one
UPDATE otp_challenge
SET attempts = attempts + $1
WHERE id = $2 
 AND attempts < $3
 AND expires_at < NOW()
RETURNING attempts
`

type OtpChallengeIncAttemptParams struct {
	Inc           pgtype.Int4 `json:"inc"`
	ID            uuid.UUID   `json:"id"`
	Attemptslimit pgtype.Int4 `json:"attemptslimit"`
}

// OtpChallengeIncAttempt
//
//	UPDATE otp_challenge
//	SET attempts = attempts + $1
//	WHERE id = $2
//	 AND attempts < $3
//	 AND expires_at < NOW()
//	RETURNING attempts
func (q *Queries) OtpChallengeIncAttempt(ctx context.Context, arg OtpChallengeIncAttemptParams) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, otpChallengeIncAttempt, arg.Inc, arg.ID, arg.Attemptslimit)
	var attempts pgtype.Int4
	err := row.Scan(&attempts)
	return attempts, err
}

const otpChallengeInsert = `-- name: OtpChallengeInsert :one
INSERT INTO otp_challenge (
    otp_hash,
    attempts,
    channel,
    purpose,
    expires_at
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
RETURNING id
`

type OtpChallengeInsertParams struct {
	OtpHash   string             `json:"otp_hash"`
	Attempts  pgtype.Int4        `json:"attempts"`
	Channel   string             `json:"channel"`
	Purpose   string             `json:"purpose"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

// OtpChallengeInsert
//
//	INSERT INTO otp_challenge (
//	    otp_hash,
//	    attempts,
//	    channel,
//	    purpose,
//	    expires_at
//	)
//	VALUES (
//	    $1,
//	    $2,
//	    $3,
//	    $4,
//	    $5
//	)
//	RETURNING id
func (q *Queries) OtpChallengeInsert(ctx context.Context, arg OtpChallengeInsertParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, otpChallengeInsert,
		arg.OtpHash,
		arg.Attempts,
		arg.Channel,
		arg.Purpose,
		arg.ExpiresAt,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
